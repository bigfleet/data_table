h1. data_table:


h2. Goal:

h3. Give a little...
Define a filter in your controller, like so:

<pre><code>
filter_spec(:cars ) do |f|
  f.element(:color) do |e|
    e.default  "All"
    e.option   "Blue",          'blue'
    e.option   "Green",         'green'
  end
end
</code></pre>


h3. get a lot.

h4. In your controlller

You get two ways of communicating with a finder in the model layer that
faithfully represent what your user is looking for.

h5. When the user has made no selection

<pre><code>
YourController#conditions_for(:cars) => []
</code></pre>

<pre><code>
YourController#options_for(:cars) => {:color => nil}
</code></pre>

h5. When the user has made a selection of blue

<pre><code>
YourController#conditions_for(:cars) => ["color => ?", 'blue']
</code></pre>

<pre><code>
YourController#options_for(:cars) => {:color => 'blue'}
</code></pre>

h4. In the view

<pre><code>
</code></pre>


* helpers on the front end to render selection box filters that know what option was selected, if any
* asking for a set of additional conditions to pass to a model-based finder
* helpers that avoid rendering complex filter data in query params
* sorting "for free"
* AJAX or non-AJAX modes

h2. Philosophy

* Sorting, filtering, and pagination are inter-related

Why aren't we all using client-side sorting?  That's easy to implement!  Oh, wait, that's only for the records that were returned to the screen.  And if you've sorted or filtered, it's OK if clicking for the second page of results resets your end user's intentions, right?  Nope.

* Pagination is already a public problem in the Rails space

This project will look to integrate with other plugins in this space rather than offering an alternative implementation.

* Finders in the model are the place for complex queries

This project's philosophy is that's where complex queries lead to the overall highest quality of testing.

* Easy things should be easy...

In many cases, a filter will just be operating on a couple of important fields on a model.  In these cases, the filter itself could be made capable of generating ActiveRecord-ready conditions that can be passed directly to a finder for direct use.

* Difficult things should be possible

Sometimes, things get pretty hairy in those finders.  For times when the filter's AR-ready conditions cannot be reliable, the filter should still provide an expressive options hash which the finder code can inspect before ultimately issuing a query.