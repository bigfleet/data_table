h1. data_table:


h2. Goal:

h3. Give a little...

Define a filter in your controller, like so:

<pre><code>
filter_spec(:cars ) do |f|
  f.element(:color) do |e|
    e.default  "All"
    e.option   "Blue",          'blue'
    e.option   "Green",         'green'
  end
end
</code></pre>


h3. get a lot.

h4. In your controlller

You get two ways of communicating with a finder in the model layer that
faithfully represent what your user is looking for.

h5. When the user has made no selection

<pre><code>
YourController#conditions_for(:cars) => []
</code></pre>

<pre><code>
YourController#options_for(:cars) => {:color => nil}
</code></pre>

h5. When the user has made a selection of blue

<pre><code>
YourController#conditions_for(:cars) => ["color => ?", 'blue']
</code></pre>

<pre><code>
YourController#options_for(:cars) => {:color => 'blue'}
</code></pre>

h4. In the view


<pre><code>
filter_form(:cars) 
</code></pre>

This fellow recognizes what, if any, options were selected, respects your
selection of URL to use for form submission, can be used in AJAX or
non-AJAX mode, and many other goodies.

<pre><code>
sort_header(:cars) 
</code></pre>

This fellow knows which sorting scheme has been selected, knows of preferred
sort orders for other sorts that aren't being used at the moment, and
communicates with the filter so that a user has a seamless experience when
going back and forth between sorting and filtering in AJAX or non-AJAX modes.

h2. For more information.

If you are interested in seeing more specifically what kinds of filtration 
that you can do, check out these wishlists.  I have not yet updated them
to be in line with the codebase, but it should give you a lot better idea
about the API that I am aiming for.

* "Filtering":http://github.com/bigfleet/data_table/wikis/filteringwishlist
* "Sorting":http://github.com/bigfleet/data_table/wikis/sortingwishlist
* "UI":http://github.com/bigfleet/data_table/wikis/uiwishlist

h2. Philosophy

* Sorting, filtering, and pagination are inter-related

Why aren't we all using client-side sorting?  That's easy to implement!  Oh, wait, that's only for the records that were returned to the screen.  And if you've sorted or filtered, it's OK if clicking for the second page of results resets your end user's intentions, right?  Nope.

* Pagination is already a public problem in the Rails space

This project will look to integrate with other plugins in this space rather than offering an alternative implementation.

* Finders in the model are the place for complex queries

This project's philosophy is that's where complex queries lead to the overall highest quality of testing.

* Easy things should be easy...

In many cases, a filter will just be operating on a couple of important fields on a model.  In these cases, the filter itself could be made capable of generating ActiveRecord-ready conditions that can be passed directly to a finder for direct use.

* Difficult things should be possible

Sometimes, things get pretty hairy in those finders.  For times when the filter's AR-ready conditions cannot be reliable, the filter should still provide an expressive options hash which the finder code can inspect before ultimately issuing a query.